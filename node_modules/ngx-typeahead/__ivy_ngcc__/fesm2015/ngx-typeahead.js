import { __decorate } from 'tslib';
import { HttpParams, HttpClient, HttpClientModule, HttpClientJsonpModule } from '@angular/common/http';
import { EventEmitter, ElementRef, ViewContainerRef, ChangeDetectorRef, Input, Output, ViewChild, TemplateRef, HostListener, Component, NgModule } from '@angular/core';
import { Subject, of } from 'rxjs';
import { filter, map, debounceTime, concat, distinctUntilChanged, tap, switchMap } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common/http';
import * as ɵngcc2 from '@angular/common';

function NgxTypeAheadComponent_ng_template_0_section_0_button_2_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵelement(1, "i", 8);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const result_r4 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", result_r4, "");
} }
function NgxTypeAheadComponent_ng_template_0_section_0_button_2_ng_template_2_Template(rf, ctx) { }
const _c0 = function (a0, a1) { return { result: a0, index: a1 }; };
const _c1 = function (a0) { return { $implicit: a0 }; };
function NgxTypeAheadComponent_ng_template_0_section_0_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 5);
    ɵngcc0.ɵɵlistener("click", function NgxTypeAheadComponent_ng_template_0_section_0_button_2_Template_button_click_0_listener() { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r10); const result_r4 = restoredCtx.$implicit; const i_r5 = restoredCtx.index; const ctx_r9 = ɵngcc0.ɵɵnextContext(3); return ctx_r9.handleSelectionClick(result_r4, i_r5); });
    ɵngcc0.ɵɵtemplate(1, NgxTypeAheadComponent_ng_template_0_section_0_button_2_span_1_Template, 3, 1, "span", 6);
    ɵngcc0.ɵɵtemplate(2, NgxTypeAheadComponent_ng_template_0_section_0_button_2_ng_template_2_Template, 0, 0, "ng-template", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const result_r4 = ctx.$implicit;
    const i_r5 = ctx.index;
    const ctx_r3 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵclassProp("active", ctx_r3.markIsActive(i_r5, result_r4));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r3.taItemTpl);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r3.taItemTpl)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(8, _c1, ɵngcc0.ɵɵpureFunction2(5, _c0, result_r4, i_r5)));
} }
function NgxTypeAheadComponent_ng_template_0_section_0_Template(rf, ctx) { if (rf & 1) {
    const _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "section", 2)(1, "div", 3);
    ɵngcc0.ɵɵlistener("click", function NgxTypeAheadComponent_ng_template_0_section_0_Template_div_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r11 = ɵngcc0.ɵɵnextContext(2); return ctx_r11.hideSuggestions(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(2, NgxTypeAheadComponent_ng_template_0_section_0_button_2_Template, 3, 10, "button", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r2.results);
} }
function NgxTypeAheadComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NgxTypeAheadComponent_ng_template_0_section_0_Template, 3, 1, "section", 1);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.showSuggestions);
} }
var Key;
(function (Key) {
    Key["Backspace"] = "Backspace";
    Key["Tab"] = "Tab";
    Key["Enter"] = "Enter";
    Key["ShiftLeft"] = "ShiftLeft";
    Key["ShiftRight"] = "ShiftRight";
    Key["Escape"] = "Escape";
    Key["ArrowLeft"] = "ArrowLeft";
    Key["ArrowRight"] = "ArrowRight";
    Key["ArrowUp"] = "ArrowUp";
    Key["ArrowDown"] = "ArrowDown";
    // http://unixpapa.com/js/key.html
    Key["MetaLeft"] = "MetaLeft";
    Key["MetaRight"] = "MetaRight";
})(Key || (Key = {}));

function validateNonCharKeyCode(keyCode) {
    return [
        Key.Enter,
        Key.Tab,
        Key.ShiftLeft,
        Key.ShiftRight,
        Key.ArrowLeft,
        Key.ArrowUp,
        Key.ArrowRight,
        Key.ArrowDown,
        Key.MetaLeft,
        Key.MetaRight,
    ].every((codeKey) => codeKey !== keyCode);
}
function validateArrowKeys(keyCode) {
    return keyCode === Key.ArrowDown || keyCode === Key.ArrowUp;
}
function isIndexActive(index, currentIndex) {
    return index === currentIndex;
}
function isEnterKey(event) {
    return event.code === Key.Enter;
}
function isEscapeKey(event) {
    // tslint:disable-next-line: deprecation
    return event.code === Key.Escape;
}
function createParamsForQuery(query, queryParamKey = 'q', customParams = {}) {
    const searchParams = Object.assign({ [queryParamKey]: query }, customParams);
    // tslint:disable-next-line
    const setParam = (acc, param) => acc.set(param, searchParams[param]);
    const params = Object.keys(searchParams).reduce(setParam, new HttpParams());
    return params;
}
function resolveApiMethod(method = '') {
    const isMethodValid = [
        'get',
        'post',
        'put',
        'delete',
        'patch',
        'request',
    ].some((methodName) => method === methodName);
    const apiMethod = isMethodValid ? method : 'get';
    return apiMethod;
}
const NO_INDEX = -1;
function resolveNextIndex(currentIndex, stepUp, listLength = 10) {
    const step = stepUp ? 1 : -1;
    const topLimit = listLength - 1;
    const bottomLimit = NO_INDEX;
    const currentResultIndex = currentIndex + step;
    let resultIndex = currentResultIndex;
    if (currentResultIndex === topLimit + 1) {
        resultIndex = bottomLimit;
    }
    if (currentResultIndex === bottomLimit - 1) {
        resultIndex = topLimit;
    }
    return resultIndex;
}
function toJsonpSingleResult(response) {
    return response[1];
}
function toJsonpFinalResults(results) {
    return results.map((result) => result[0]);
}
function hasCharacters(query) {
    return query.length > 0;
}
function toFormControlValue(e) {
    return e.target.value;
}
function resolveItemValue(item, fieldsToExtract, caseSensitive = false) {
    let newItem = item;
    if (!item.hasOwnProperty('length')) {
        const fields = !fieldsToExtract.length
            ? Object.keys(item)
            : fieldsToExtract;
        newItem = fields.reduce((acc, cur) => `${acc}${item[cur]}`, '');
    }
    return caseSensitive ? newItem : newItem.toLowerCase();
}

/*
 using an external template:
 <input [taItemTpl]="itemTpl" >

  <ng-template #itemTpl let-result>
    <strong>MY {{ result.result }}</strong>
  </ng-template>
*/
let NgxTypeAheadComponent = class NgxTypeAheadComponent {
    constructor(element, viewContainer, http, cdr) {
        this.element = element;
        this.viewContainer = viewContainer;
        this.http = http;
        this.cdr = cdr;
        this.showSuggestions = false;
        this.results = [];
        this.taUrl = '';
        this.taParams = {};
        this.taQueryParam = 'q';
        this.taApi = 'jsonp';
        this.taApiMethod = 'get';
        this.taList = [];
        this.taListItemField = [];
        this.taListItemLabel = '';
        this.taDebounce = 300;
        this.taAllowEmpty = false;
        this.taCaseSensitive = false;
        this.taDisplayOnFocus = false;
        this.taSelected = new EventEmitter();
        this.suggestionIndex = 0;
        this.subscriptions = [];
        this.activeResult = '';
        this.searchQuery = '';
        this.selectedItem = {};
        this.resultsAsItems = [];
        this.keydown$ = new Subject();
        this.keyup$ = new Subject();
    }
    handleEsc(event) {
        if (isEscapeKey(event)) {
            this.hideSuggestions();
            event.preventDefault();
        }
        this.keydown$.next(event);
    }
    onkeyup(event) {
        event.preventDefault();
        event.stopPropagation();
        this.keyup$.next(event);
    }
    onClick() {
        if (this.taDisplayOnFocus) {
            this.displaySuggestions();
        }
    }
    ngOnInit() {
        this.filterEnterEvent(this.keydown$);
        this.listenAndSuggest(this.keyup$);
        this.navigateWithArrows(this.keydown$);
        this.renderTemplate();
    }
    ngOnDestroy() {
        this.keydown$.complete();
        this.keyup$.complete();
    }
    renderTemplate() {
        if (!this.suggestionsTplRef) {
            console.error('NO NGXTA Template Found. Requires NG9');
            return;
        }
        this.viewContainer.createEmbeddedView(this.suggestionsTplRef);
        this.cdr.markForCheck();
    }
    listenAndSuggest(obs) {
        obs
            .pipe(
        // tslint:disable-next-line: deprecation
        filter((e) => validateNonCharKeyCode(e.code)), map(toFormControlValue), debounceTime(this.taDebounce), 
        // tslint:disable-next-line: deprecation
        concat(), distinctUntilChanged(), filter((query) => this.taAllowEmpty || hasCharacters(query)), tap((query) => (this.searchQuery = query)), switchMap((query) => this.suggest(query)))
            .subscribe((results) => {
            this.assignResults(results);
            // this.updateIndex(Key.ArrowDown);
            this.displaySuggestions();
        });
    }
    assignResults(results) {
        const labelForDisplay = this.taListItemLabel;
        this.resultsAsItems = results;
        this.results = results.map((item) => labelForDisplay ? item[labelForDisplay] : item);
        this.suggestionIndex = NO_INDEX;
        if (!results || !results.length) {
            this.activeResult = this.searchQuery;
        }
    }
    filterEnterEvent(elementObs) {
        elementObs.pipe(filter(isEnterKey)).subscribe((event) => {
            this.handleSelectSuggestion(this.activeResult);
        });
    }
    navigateWithArrows(elementObs) {
        elementObs
            .pipe(map((e) => e.key), filter((key) => validateArrowKeys(key)))
            .subscribe((key) => {
            this.updateIndex(key);
            this.displaySuggestions();
        });
    }
    updateIndex(keyCode) {
        this.suggestionIndex = resolveNextIndex(this.suggestionIndex, keyCode === Key.ArrowDown, this.results.length);
    }
    displaySuggestions() {
        this.showSuggestions = true;
        this.cdr.markForCheck();
    }
    suggest(query) {
        return this.taList.length
            ? this.createListSource(this.taList, query)
            : this.request(query);
    }
    /**
     * peforms a jsonp/http request to search with query and params
     * @param query the query to search from the remote source
     */
    request(query) {
        const url = this.taUrl;
        const searchConfig = createParamsForQuery(query, this.taQueryParam, this.taParams);
        const options = {
            params: searchConfig,
        };
        const isJsonpApi = this.taApi === 'jsonp';
        return isJsonpApi
            ? this.requestJsonp(url, options, this.taCallbackParamValue)
            : this.requestHttp(url, options);
    }
    requestHttp(url, options) {
        const apiMethod = resolveApiMethod(this.taApiMethod);
        return this.http[apiMethod](url, options);
    }
    requestJsonp(url, options, callback = 'callback') {
        const params = options.params.toString();
        return this.http
            .jsonp(`${url}?${params}`, callback)
            .pipe(map(toJsonpSingleResult), map(toJsonpFinalResults));
    }
    markIsActive(index, result) {
        const isActive = isIndexActive(index, this.suggestionIndex);
        if (isActive) {
            this.activeResult = result;
        }
        return isActive;
    }
    handleSelectionClick(suggestion, index) {
        this.suggestionIndex = index;
        this.handleSelectSuggestion(suggestion);
    }
    handleSelectSuggestion(suggestion) {
        const result = this.resultsAsItems.length
            ? this.resultsAsItems[this.suggestionIndex]
            : suggestion;
        this.hideSuggestions();
        const resolvedResult = this.suggestionIndex === NO_INDEX ? this.searchQuery : result;
        this.taSelected.emit(resolvedResult);
    }
    hideSuggestions() {
        this.showSuggestions = false;
    }
    hasItemTemplate() {
        return this.taItemTpl !== undefined;
    }
    createListSource(list, query) {
        const sanitizedQuery = this.taCaseSensitive ? query : query.toLowerCase();
        const fieldsToExtract = this.taListItemField;
        return of(list.filter((item) => {
            return resolveItemValue(item, fieldsToExtract, this.taCaseSensitive).includes(sanitizedQuery);
        }));
    }
};
NgxTypeAheadComponent.ɵfac = function NgxTypeAheadComponent_Factory(t) { return new (t || NgxTypeAheadComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.HttpClient), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NgxTypeAheadComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NgxTypeAheadComponent, selectors: [["ngx-typeahead"], ["", "ngxTypeahead", ""]], viewQuery: function NgxTypeAheadComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(TemplateRef, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.suggestionsTplRef = _t.first);
    } }, hostBindings: function NgxTypeAheadComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function NgxTypeAheadComponent_keydown_HostBindingHandler($event) { return ctx.handleEsc($event); })("keyup", function NgxTypeAheadComponent_keyup_HostBindingHandler($event) { return ctx.onkeyup($event); })("click", function NgxTypeAheadComponent_click_HostBindingHandler() { return ctx.onClick(); });
    } }, inputs: { taUrl: "taUrl", taParams: "taParams", taQueryParam: "taQueryParam", taApi: "taApi", taApiMethod: "taApiMethod", taList: "taList", taListItemField: "taListItemField", taListItemLabel: "taListItemLabel", taDebounce: "taDebounce", taAllowEmpty: "taAllowEmpty", taCaseSensitive: "taCaseSensitive", taDisplayOnFocus: "taDisplayOnFocus", taItemTpl: "taItemTpl", taCallbackParamValue: "taCallbackParamValue" }, outputs: { taSelected: "taSelected" }, decls: 2, vars: 0, consts: [["suggestionsTplRef", ""], ["class", "ta-results list-group", 4, "ngIf"], [1, "ta-results", "list-group"], [1, "ta-backdrop", 3, "click"], ["type", "button", "class", "ta-item list-group-item", 3, "active", "click", 4, "ngFor", "ngForOf"], ["type", "button", 1, "ta-item", "list-group-item", 3, "click"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "fa", "fa-search"]], template: function NgxTypeAheadComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NgxTypeAheadComponent_ng_template_0_Template, 1, 1, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgForOf, ɵngcc2.NgTemplateOutlet], styles: [".ta-results[_ngcontent-%COMP%] {\n        position: absolute;\n      }\n      .ta-backdrop[_ngcontent-%COMP%] {\n        bottom: 0;\n        left: 0;\n        position: fixed;\n        right: 0;\n        top: 0;\n        z-index: 1;\n      }\n      .ta-item[_ngcontent-%COMP%] {\n        position: relative;\n        z-index: 2;\n        display: block;\n      }"] });
NgxTypeAheadComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: HttpClient },
    { type: ChangeDetectorRef }
];
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taItemTpl", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taUrl", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taParams", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taQueryParam", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taCallbackParamValue", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taApi", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taApiMethod", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taList", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taListItemField", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taListItemLabel", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taDebounce", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taAllowEmpty", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taCaseSensitive", void 0);
__decorate([
    Input()
], NgxTypeAheadComponent.prototype, "taDisplayOnFocus", void 0);
__decorate([
    Output()
], NgxTypeAheadComponent.prototype, "taSelected", void 0);
__decorate([
    ViewChild(TemplateRef, { static: true })
], NgxTypeAheadComponent.prototype, "suggestionsTplRef", void 0);
__decorate([
    HostListener('keydown', ['$event'])
], NgxTypeAheadComponent.prototype, "handleEsc", null);
__decorate([
    HostListener('keyup', ['$event'])
], NgxTypeAheadComponent.prototype, "onkeyup", null);
__decorate([
    HostListener('click')
], NgxTypeAheadComponent.prototype, "onClick", null);

let NgxTypeaheadModule = class NgxTypeaheadModule {
};
NgxTypeaheadModule.ɵfac = function NgxTypeaheadModule_Factory(t) { return new (t || NgxTypeaheadModule)(); };
NgxTypeaheadModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NgxTypeaheadModule });
NgxTypeaheadModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, HttpClientModule, HttpClientJsonpModule], CommonModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxTypeAheadComponent, [{
        type: Component,
        args: [{
                // tslint:disable-next-line: component-selector
                selector: 'ngx-typeahead, [ngxTypeahead]',
                template: `
    <ng-template #suggestionsTplRef>
      <section class="ta-results list-group" *ngIf="showSuggestions">
        <div class="ta-backdrop" (click)="hideSuggestions()"></div>
        <button
          type="button"
          class="ta-item list-group-item"
          *ngFor="let result of results; let i = index"
          [class.active]="markIsActive(i, result)"
          (click)="handleSelectionClick(result, i)"
        >
          <span *ngIf="!taItemTpl"
            ><i class="fa fa-search"></i> {{ result }}</span
          >
          <ng-template
            [ngTemplateOutlet]="taItemTpl"
            [ngTemplateOutletContext]="{
              $implicit: { result: result, index: i }
            }"
          ></ng-template>
        </button>
      </section>
    </ng-template>
  `,
                styles: [`
      .ta-results {
        position: absolute;
      }
      .ta-backdrop {
        bottom: 0;
        left: 0;
        position: fixed;
        right: 0;
        top: 0;
        z-index: 1;
      }
      .ta-item {
        position: relative;
        z-index: 2;
        display: block;
      }
    `]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc1.HttpClient }, { type: ɵngcc0.ChangeDetectorRef }]; }, { taUrl: [{
            type: Input
        }], taParams: [{
            type: Input
        }], taQueryParam: [{
            type: Input
        }], taApi: [{
            type: Input
        }], taApiMethod: [{
            type: Input
        }], taList: [{
            type: Input
        }], taListItemField: [{
            type: Input
        }], taListItemLabel: [{
            type: Input
        }], taDebounce: [{
            type: Input
        }], taAllowEmpty: [{
            type: Input
        }], taCaseSensitive: [{
            type: Input
        }], taDisplayOnFocus: [{
            type: Input
        }], taSelected: [{
            type: Output
        }], handleEsc: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], onkeyup: [{
            type: HostListener,
            args: ['keyup', ['$event']]
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], taItemTpl: [{
            type: Input
        }], taCallbackParamValue: [{
            type: Input
        }], suggestionsTplRef: [{
            type: ViewChild,
            args: [TemplateRef, { static: true }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxTypeaheadModule, [{
        type: NgModule,
        args: [{
                declarations: [NgxTypeAheadComponent],
                imports: [CommonModule, HttpClientModule, HttpClientJsonpModule],
                exports: [NgxTypeAheadComponent, CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxTypeaheadModule, { declarations: function () { return [NgxTypeAheadComponent]; }, imports: function () { return [CommonModule, HttpClientModule, HttpClientJsonpModule]; }, exports: function () { return [NgxTypeAheadComponent, CommonModule]; } }); })();

/*
 * Public API Surface of ngx-typeahead
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxTypeAheadComponent, NgxTypeaheadModule };

//# sourceMappingURL=ngx-typeahead.js.map